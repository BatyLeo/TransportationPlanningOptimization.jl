var documenterSearchIndex = {"docs":
[{"location":"#NetworkDesignOptimization","page":"Home","title":"NetworkDesignOptimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NetworkDesignOptimization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#NetworkDesignOptimization.FullCommodity","page":"Home","title":"NetworkDesignOptimization.FullCommodity","text":"struct FullCommodity{I}\n\nCommodity data structure that should be instantiated by the user's parser. This then will be used internally to instantiate an instance with more optimized data structures.\n\nFields\n\norigin_id::Any\ndestination_id::Any\nsize::Float64\ndelivery_time_step::Int64\nmax_delivery_time::Int64\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.TypedInstance","page":"Home","title":"NetworkDesignOptimization.TypedInstance","text":"TypedInstance{CostUnion, InfoUnion}\n\nA type-stable container for network design instances with heterogeneous arc cost functions. This struct automatically handles type stability when you have multiple cost function types.\n\nType Parameters\n\nCostUnion: A Union type of all cost functions used (e.g., Union{LinearArcCost, BinPackingArcCost})\nInfoUnion: A Union type of all info types used\n\nExample\n\n# Define your cost types\nconst MyCostTypes = Union{LinearArcCost, BinPackingArcCost}\n\n# Create instance (arcs will be automatically converted)\ninstance = TypedInstance{MyCostTypes}(nodes, arcs)\n\n# Access type-stable arcs\nfor arc in instance.arcs\n    cost = evaluate(arc.cost)  # Fully type-stable!\nend\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.collect_arcs-Tuple{Tuple, Any}","page":"Home","title":"NetworkDesignOptimization.collect_arcs","text":"collect_arcs(cost_types, arcs; validate=true)\n\nCollect an iterable of NetworkArcs into a type-stable vector with the specified cost types. This is useful for creating heterogeneous arc collections with multiple cost function types while maintaining type stability.\n\nArguments\n\ncost_types: A tuple or Union of cost function types\nTuple syntax: (LinearArcCost, BinPackingArcCost)\nUnion syntax: Union{LinearArcCost, BinPackingArcCost}\narcs: Iterable of NetworkArc objects with potentially different cost types\nvalidate: Whether to validate that all arc cost types are included (default: true)\n\nExamples\n\n# Using tuple (recommended)\narcs = [NetworkArc(cost=LinearArcCost(1.0), ...), NetworkArc(cost=BinPackingArcCost(2.0, 10), ...)]\ntyped_arcs = collect_arcs((LinearArcCost, BinPackingArcCost), arcs)\n\n# Using Union (also works)\nconst MyCostTypes = Union{LinearArcCost, BinPackingArcCost}\ntyped_arcs = collect_arcs(MyCostTypes, arcs)\n\n\n\n\n\n","category":"method"}]
}
