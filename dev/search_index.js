var documenterSearchIndex = {"docs":
[{"location":"#NetworkDesignOptimization","page":"Home","title":"NetworkDesignOptimization","text":"Documentation for NetworkDesignOptimization.\n\n","category":"section"},{"location":"#NetworkDesignOptimization.Commodity","page":"Home","title":"NetworkDesignOptimization.Commodity","text":"struct Commodity{is_date_arrival, ID, I}\n\nUser-facing commodity data structure for parsing input data.\n\nThis structure is designed to be easy to instantiate from CSV, JSON, or other data sources. Once all commodities are loaded, they are consolidated into optimized internal structures (Commodity, Order, Bundle) based on problem-specific consolidation rules.\n\nType Parameters\n\nis_date_arrival::Bool: true if date represents arrival, false if departure\nID: Type for node identifiers (e.g., String, Int)\nI: Type for additional problem-specific information\n\nFields\n\norigin_id::Any: origin node identifier\ndestination_id::Any: destination node identifier\ndate::Dates.DateTime: date information associated with the commodity\nmax_delivery_time::Dates.Period\nsize::Float64: size of the commodity (we assume 1D approximation)\nquantity::Int64: quantity of the commodity\ninfo::Any: additional problem-specific information\n\nExamples\n\n# Inbound logistics (arrival date)\nCommodity(\n    origin_id = \"SUPPLIER_A\",\n    destination_id = \"PLANT_PARIS\",\n    arrival_date = Date(2025, 11, 20),\n    size = 150.0,\n    info = (part_id = \"ENGINE_V6\", priority = :high)\n)\n\n# Outbound logistics (departure date)\nCommodity(\n    origin_id = \"PLANT_PARIS\",\n    destination_id = \"DEALER_LYON\",\n    departure_date = Date(2025, 11, 18),\n    size = 1.0,  # 1 vehicle\n    info = (model = \"Clio\", color = \"Blue\")\n)\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.collect_arcs-Tuple{Tuple, Any}","page":"Home","title":"NetworkDesignOptimization.collect_arcs","text":"collect_arcs(cost_types, arcs; validate=true)\n\nCollect an iterable of NetworkArcs into a type-stable vector with the specified cost types. This is useful for creating heterogeneous arc collections with multiple cost function types while maintaining type stability.\n\nArguments\n\ncost_types: A tuple or Union of cost function types\nTuple syntax: (LinearArcCost, BinPackingArcCost)\nUnion syntax: Union{LinearArcCost, BinPackingArcCost}\narcs: Iterable of NetworkArc objects with potentially different cost types\nvalidate: Whether to validate that all arc cost types are included (default: true)\n\nExamples\n\n# Using tuple (recommended)\narcs = [NetworkArc(cost=LinearArcCost(1.0), ...), NetworkArc(cost=BinPackingArcCost(2.0, 10), ...)]\ntyped_arcs = collect_arcs((LinearArcCost, BinPackingArcCost), arcs)\n\n# Using Union (also works)\nconst MyCostTypes = Union{LinearArcCost, BinPackingArcCost}\ntyped_arcs = collect_arcs(MyCostTypes, arcs)\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.period_steps-Tuple{Dates.Period, Dates.Period}","page":"Home","title":"NetworkDesignOptimization.period_steps","text":"period_steps(p::Period, step::Period; roundup=floor)::Int\n\nCompute how many complete step units fit into period p.\n\nArguments\n\np::Period: the period to measure\nstep::Period: the step size\nroundup::Function: ceil (default) or floor\n\nReturns\n\nAn integer representing the number of steps.\n\nExamples\n\nperiod_steps(Day(10), Week(1))                    # => 2 (default ceil)\nperiod_steps(Day(10), Week(1); roundup=floor)     # => 1\nperiod_steps(Hour(25), Week(1))                   # => 1\nperiod_steps(Day(1), Hour(12); roundup=floor)     # => 2\n\n\n\n\n\n","category":"method"}]
}
