var documenterSearchIndex = {"docs":
[{"location":"#TransportationPlanningOptimization","page":"Home","title":"TransportationPlanningOptimization","text":"Documentation for TransportationPlanningOptimization.\n\n","category":"section"},{"location":"#TransportationPlanningOptimization.SHORTCUT_ARC","page":"Home","title":"TransportationPlanningOptimization.SHORTCUT_ARC","text":"A predefined NetworkArc representing a zero-cost, zero-duration transition (e.g., waiting at a node).\n\n\n\n\n\n","category":"constant"},{"location":"#TransportationPlanningOptimization.AbstractArcCostFunction","page":"Home","title":"TransportationPlanningOptimization.AbstractArcCostFunction","text":"abstract type AbstractArcCostFunction\n\nAbstract base type for cost functions defined on network arcs. Concrete subtypes determine how load/size on an arc is translated into a financial or performance cost.\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Arc","page":"Home","title":"TransportationPlanningOptimization.Arc","text":"struct Arc{C<:AbstractArcCostFunction, K, T<:Dates.Period}\n\nRepresentation of an arc in the network graph.\n\nFields\n\norigin_id::String: id of the origin node\ndestination_id::String: id of the destination node\ntravel_time::Dates.Period: travel time in number of discrete time steps (0 if less than the time discretization step)\ncapacity::Int64: capacity of the arc (in size units)\ncost::AbstractArcCostFunction: cost function associated with the arc\ninfo::Any: additional information associated with the arc\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Bin","page":"Home","title":"TransportationPlanningOptimization.Bin","text":"struct Bin{C<:LightCommodity}\n\nA representation of a bin/truck used in bin-packing cost functions.\n\nFields\n\ncommodities::Vector{C} where C<:LightCommodity: List of commodities assigned to this bin\ntotal_size::Float64: Total size of all commodities in the bin\nmax_capacity::Float64: Capacity of the bin\nremaining_capacity::Float64: Remaining capacity in the bin\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.BinPackingArcCost","page":"Home","title":"TransportationPlanningOptimization.BinPackingArcCost","text":"struct BinPackingArcCost <: AbstractArcCostFunction\n\nA bin-packing (or step) cost function. A fixed cost is incurred for each bin/truck needed.\n\nFields\n\ncost_per_bin::Float64: Fixed cost for each bin used (e.g., cost per truck)\nbin_capacity::Int64: Capacity of a single bin/truck\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Bundle","page":"Home","title":"TransportationPlanningOptimization.Bundle","text":"struct Bundle{O<:Order}\n\nA collection of Orders that share the same origin and destination. While orders in a bundle can have different delivery dates, they should follow the same path (in the travel time graph).\n\nFields\n\norders::Vector{O} where O<:Order\norigin_id::String\ndestination_id::String\nforbidden_nodes::Set{String}: set of node IDs that are forbidden for this bundle (cannot be traversed)\nforbidden_arcs::Set{Tuple{String, String}}: set of arc (originid, destinationid) pairs that are forbidden for this bundle\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Commodity","page":"Home","title":"TransportationPlanningOptimization.Commodity","text":"struct Commodity{is_date_arrival, ID, I}\n\nUser-facing commodity data structure for parsing input data.\n\nThis structure is designed to be easy to instantiate from CSV, JSON, or other data sources. Once all commodities are loaded, they are consolidated into optimized internal structures (Commodity, Order, Bundle) based on problem-specific consolidation rules.\n\nType Parameters\n\nis_date_arrival::Bool: \ntrue: date represents the arrival deadline at the destination.\nfalse: date represents the earliest departure time (release) from the origin.\nID: Type for node identifiers (e.g., String, Int).\nI: Type for additional problem-specific information.\n\nFields\n\norigin_id::Any: origin node identifier\ndestination_id::Any: destination node identifier\ndate::Dates.DateTime: date information associated with the commodity\nmax_delivery_time::Dates.Period\nsize::Float64: size of the commodity (we assume 1D approximation)\nquantity::Int64: quantity of the commodity\nforbidden_node_ids::Vector: list of forbidden node identifiers for this commodity\nforbidden_arcs::Array{Tuple{ID, ID}, 1} where ID: list of forbidden arcs for this commodity\ninfo::Any: additional problem-specific information\n\nExamples\n\n# Inbound logistics (arrival date)\nCommodity(\n    origin_id = \"SUPPLIER_A\",\n    destination_id = \"PLANT_PARIS\",\n    arrival_date = DateTime(2025, 11, 20),\n    size = 150.0,\n    info = (part_id = \"ENGINE_V6\", priority = :high)\n)\n\n# Outbound logistics (departure date)\nCommodity(\n    origin_id = \"PLANT_PARIS\",\n    destination_id = \"DEALER_LYON\",\n    departure_date = DateTime(2025, 11, 18),\n    size = 1.0,\n    info = (model = \"Clio\", color = \"Blue\")\n)\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Commodity-Union{Tuple{}, Tuple{I}, Tuple{ID}} where {ID, I}","page":"Home","title":"TransportationPlanningOptimization.Commodity","text":"Commodity(\n;\n    origin_id,\n    destination_id,\n    size,\n    quantity,\n    max_delivery_time,\n    arrival_date,\n    departure_date,\n    forbidden_node_ids,\n    forbidden_arcs,\n    info\n)\n\n\nUser-friendly constructor for Commodity.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.Instance","page":"Home","title":"TransportationPlanningOptimization.Instance","text":"struct Instance{B<:Bundle, G<:NetworkGraph, TSG<:TimeSpaceGraph, TTG<:TravelTimeGraph}\n\nAn Instance represents a transportation planning problem instance, containing bundles of orders, a network graph, and a time horizon.\n\nFields\n\nbundles::Vector{B} where B<:Bundle: list of bundles in the instance\nnetwork_graph::NetworkGraph: underlying network graph\ntime_horizon_length::Int64: length of the time horizon in discrete time steps\ntime_step::Dates.Period: discretization time step for the instance\ntime_step_to_date::Vector{Dates.Date}: mapping from time step index to date\ntime_space_graph::TimeSpaceGraph: time expanded graph (for order paths)\ntravel_time_graph::TravelTimeGraph: travel time graph (for bundle paths)\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Instance-Union{Tuple{I}, Tuple{ID}, Tuple{is_date_arrival}, Tuple{Vector{<:NetworkNode}, Vector{<:Arc}, Array{Commodity{is_date_arrival, ID, I}, 1}, Dates.Period}} where {is_date_arrival, ID, I}","page":"Home","title":"TransportationPlanningOptimization.Instance","text":"Instance(\n    nodes::Vector{<:NetworkNode},\n    arcs::Vector{<:Arc},\n    commodities::Vector{Commodity{is_date_arrival,ID,I}},\n    time_step::Period;\n    group_by=_default_group_by,\n    wrap_time=false,\n) where {is_date_arrival,ID,I}\n\nConstruct an Instance from high-level Arc inputs by automatically inferring cost function types.\n\nArguments\n\nnodes::Vector{<:NetworkNode}: List of nodes in the spatial network.\narcs::Vector{<:Tuple{String,String,<:NetworkArc}}: Arcs in the spatial network as (origin_id, destination_id, arc_data).\ncommodities::Vector{Commodity}: User-facing commodity specifications.\ntime_step::Period: The discrete time step size (e.g., Hour(1), Day(1)).\n\nKeywords:\n\ngroup_by (default: _default_group_by): Optional function to group commodities into Orders (default: no additional grouping).\nwrap_time (default: false): whether the time horizon should wrap (cyclic)\ncheck_bundle_feasibility (default: true): whether to validate that bundles have feasible paths after applying forbidden constraints\n\nDiscretization and Normalization\n\nStart Date: The time horizon starts at the earliest release date (for departure-based) or the earliest possible start (for arrival-based).\nTime Steps: Dates and periods are converted to discrete steps using period_steps.\nConsolidation: Commodities with the same origin, destination, and delivery step are grouped into Orders. Orders with the same origin and destination are grouped into Bundles for routing.\nGraphs: Both TimeSpaceGraph (absolute time) and TravelTimeGraph (relative time) are constructed.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.LinearArcCost","page":"Home","title":"TransportationPlanningOptimization.LinearArcCost","text":"struct LinearArcCost <: AbstractArcCostFunction\n\nA linear cost function where the cost is directly proportional to the total size/load on the arc.\n\nFields\n\ncost_per_unit_size::Float64: Unit cost per unit of size (e.g. m³, kg, etc.)\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.NetworkArc","page":"Home","title":"TransportationPlanningOptimization.NetworkArc","text":"struct NetworkArc{C<:AbstractArcCostFunction, K}\n\nRepresentation of an arc in the network graph.\n\nFields\n\ntravel_time_steps::Int64: travel time in number of discrete time steps (0 if less than the time discretization step)\ncapacity::Int64: capacity of the arc (in size units)\ncost::AbstractArcCostFunction: cost function associated with the arc\ninfo::Any: additional information associated with the arc\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.NetworkGraph","page":"Home","title":"TransportationPlanningOptimization.NetworkGraph","text":"struct NetworkGraph{G<:MetaGraphsNext.MetaGraph}\n\nA representation of the physical (spatial) network graph. Nodes are identified by String labels and store NetworkNode metadata. Edges store NetworkArc metadata.\n\nFields\n\ngraph::MetaGraphsNext.MetaGraph: The underlying MetaGraph mapping node IDs (Strings) to metadata.\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.NetworkGraph-Union{Tuple{NA}, Tuple{Vector{<:NetworkNode}, Vector{<:Tuple{String, String, NA}}}} where NA<:NetworkArc","page":"Home","title":"TransportationPlanningOptimization.NetworkGraph","text":"NetworkGraph(\n    nodes::Vector{<:NetworkNode},\n    arcs::Array{<:Tuple{String, String, NA<:NetworkArc}, 1}\n) -> NetworkGraph{G} where G<:(MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64} where {_A, _B, _C})\n\n\nConstructor for NetworkGraph. Ensures node and arc IDs are unique during creation.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.NetworkNode","page":"Home","title":"TransportationPlanningOptimization.NetworkNode","text":"struct NetworkNode{J}\n\nA node in the spatial network graph. Nodes represent physical locations and can serve as origins or destinations for commodities.\n\nFields\n\nid::String\nnode_type::Symbol\ncost::Float64\ncapacity::Int64\ninfo::Any\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.NetworkNode-Tuple{}","page":"Home","title":"TransportationPlanningOptimization.NetworkNode","text":"NetworkNode(; id, node_type, cost, capacity, info)\n\n\nConstructor for NetworkNode.\n\nNode Types (Symbol)\n\n:origin: A entry point for commodities.\n:destination: An exit point for commodities.\n:other: An intermediate or transhipment point.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.Order","page":"Home","title":"TransportationPlanningOptimization.Order","text":"struct Order{is_date_arrival, I}\n\nAn internal structure representing a group of commodities to be delivered together. Commodities in an Order share the same:\n\nOrigin node\nDestination node\nDelivery date (interpreted as a deadline or release depending on is_date_arrival)\n\nType Parameters\n\nis_date_arrival::Bool: Inherited from the commodities. true for deadline-driven, false for release-driven.\nI: Additional problem-specific information.\n\nFields\n\ncommodities::Array{LightCommodity{is_date_arrival, I}, 1} where {is_date_arrival, I}: list of commodities in the order\ntime_step::Int64: time step corresponding to the delivery arrival/departure date\nmax_transit_steps::Int64: maximum number of time steps for delivery among all commodities in the order\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.ShortcutArcCost","page":"Home","title":"TransportationPlanningOptimization.ShortcutArcCost","text":"A small marker cost function used to represent shortcut / wait arcs. This makes dispatch and checks explicit instead of relying on numeric values.\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Solution","page":"Home","title":"TransportationPlanningOptimization.Solution","text":"struct Solution{C<:LightCommodity}\n\nA solution to the network design optimization problem. It stores the chosen paths for each bundle in the TravelTimeGraph and precomputes key metrics such as commodity distributions on arcs and individual arc costs.\n\nFields\n\nbundle_paths::Vector{Vector{Int64}}: Paths for each bundle in the instance. bundle_paths[i] is a sequence of node codes in the TravelTimeGraph for the i-th bundle.\ncommodities_on_arcs::Dict{Tuple{Int64, Int64}, Vector{C}} where C<:LightCommodity: Commodities on each arc of the TimeSpaceGraph. Maps (u, v) to a list of commodities.\nbin_assignments::Dict{Tuple{Int64, Int64}, Array{Bin{C}, 1}} where C<:LightCommodity: Bin assignments on each arc (for BinPackingArcCost arcs). Maps (u, v) to a list of bins.\narc_costs::Dict{Tuple{Int64, Int64}, Float64}: Cost of each arc in the solution. Maps (u, v) to the arc's cost.\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.Solution-Union{Tuple{Instance{Bundle{Order{IDA, I}}}}, Tuple{I}, Tuple{IDA}} where {IDA, I}","page":"Home","title":"TransportationPlanningOptimization.Solution","text":"Solution(instance::Instance)\n\nInitialize an empty solution for the given instance.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.Solution-Union{Tuple{I}, Tuple{IDA}, Tuple{Vector{Vector{Int64}}, Instance{Bundle{Order{IDA, I}}}}} where {IDA, I}","page":"Home","title":"TransportationPlanningOptimization.Solution","text":"Solution(bundle_paths, instance)\n\nConstruct a Solution from bundle paths and an instance. This constructor precomputes commodity distributions on arcs, bin-packing results, and total cost.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.TimeSpaceGraph","page":"Home","title":"TransportationPlanningOptimization.TimeSpaceGraph","text":"struct TimeSpaceGraph{G}\n\nA TimeSpaceGraph represents a time-expanded version of a network graph, where each node is replicated for each time step in the time horizon.\n\nFields\n\ngraph::Any: underlying time-expanded graph\ntime_horizon_length::Int64: length of the time horizon in discrete time steps\nwrap_time::Bool: whether time wrapping is enabled for arcs that exceed the time horizon\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.TimeSpaceGraph-Tuple{NetworkGraph, Int64}","page":"Home","title":"TransportationPlanningOptimization.TimeSpaceGraph","text":"TimeSpaceGraph(\n    network_graph::NetworkGraph,\n    time_horizon_length::Int64;\n    wrap_time\n)\n\n\nConstructor for TimeSpaceGraph. Creates timed copies of all nodes and arcs from the network_graph for each step in 1:time_horizon_length.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.TravelTimeGraph","page":"Home","title":"TransportationPlanningOptimization.TravelTimeGraph","text":"struct TravelTimeGraph{is_date_arrival, G<:MetaGraphsNext.MetaGraph}\n\nA time-expanded graph where nodes represent (location, τ).  The parameter is_date_arrival (boolean) defines the semantics of τ:\n\nis_date_arrival = true (Count Down / Remaining Time):   τ represents the remaining time budget to meet a deadline.\nArcs move from τ to τ - travel_time.\nPaths enter the graph at (origin, max_duration) and exit at (destination, 0).\nis_date_arrival = false (Count Up / Elapsed Time):   τ represents the time elapsed since a release date.\nArcs move from τ to τ + travel_time.\nPaths enter the graph at (origin, 0) and exit at (destination, max_duration).\n\nFields\n\ngraph::MetaGraphsNext.MetaGraph: underlying time-expanded graph\nmax_time_steps::Int64: Maximum duration allowed for a bundle in this graph\ncost_matrix::SparseArrays.SparseMatrixCSC{Float64, Int64}: Cost matrix between timed nodes (sparse)\norigin_codes::Vector{Int64}: Map from bundle index to unique origin node code entry point\ndestination_codes::Vector{Int64}: Map from bundle index to unique destination node code exit point\nbundle_arcs::Vector{Vector{Tuple{Int64, Int64}}}: arcs usable for each bundle to ease looping through them\n\n\n\n\n\n","category":"type"},{"location":"#TransportationPlanningOptimization.TravelTimeGraph-Union{Tuple{I}, Tuple{is_date_arrival}, Tuple{NetworkGraph, Vector{<:Bundle{<:Order{is_date_arrival, I}}}}} where {is_date_arrival, I}","page":"Home","title":"TransportationPlanningOptimization.TravelTimeGraph","text":"TravelTimeGraph(\n    network_graph::NetworkGraph,\n    bundles::Array{<:Bundle{<:Order{is_date_arrival, I}}, 1}\n) -> TravelTimeGraph{_A, MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Tuple{String, Int64}, NetworkNode, NetworkArc, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64}} where _A\n\n\nConstruct a TravelTimeGraph from a NetworkGraph and a set of Bundles.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{TravelTimeGraph, Any, Any}","page":"Home","title":"Base.getindex","text":"getindex(\n    travel_time_graph::TravelTimeGraph,\n    label_1,\n    label_2\n) -> Any\n\n\nReturn edge metadata for the edge between label_1 and label_2.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{TravelTimeGraph, Any}","page":"Home","title":"Base.getindex","text":"getindex(travel_time_graph::TravelTimeGraph, label) -> Any\n\n\nReturn node metadata for label.\n\n\n\n\n\n","category":"method"},{"location":"#Base.haskey-Tuple{TravelTimeGraph, Any, Any}","page":"Home","title":"Base.haskey","text":"haskey(\n    travel_time_graph::TravelTimeGraph,\n    label_1,\n    label_2\n) -> Bool\n\n\nCheck if the travel-time graph has an edge between label_1 and label_2.\n\n\n\n\n\n","category":"method"},{"location":"#Base.haskey-Tuple{TravelTimeGraph, Any}","page":"Home","title":"Base.haskey","text":"haskey(travel_time_graph::TravelTimeGraph, label) -> Bool\n\n\nCheck if the travel-time graph has a vertex with the given label.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, Instance}","page":"Home","title":"Base.show","text":"show(io::IO, instance::Instance)\n\n\nReturn a summary of the instance.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.SimpleGraphs.add_edge!-Tuple{TravelTimeGraph, Tuple{String, Int64}, Tuple{String, Int64}, NetworkArc}","page":"Home","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(\n    travel_time_graph::TravelTimeGraph,\n    u::Tuple{String, Int64},\n    v::Tuple{String, Int64},\n    arc::NetworkArc\n) -> Bool\n\n\nAdd an arc between u and v with metadata arc to the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.SimpleGraphs.add_vertex!-Tuple{TravelTimeGraph, Tuple{String, Int64}, NetworkNode}","page":"Home","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(\n    travel_time_graph::TravelTimeGraph,\n    u::Tuple{String, Int64},\n    node::NetworkNode\n) -> Bool\n\n\nAdd a vertex with label u and metadata node to the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.has_edge-Tuple{TravelTimeGraph, Integer, Integer}","page":"Home","title":"Graphs.has_edge","text":"has_edge(\n    travel_time_graph::TravelTimeGraph,\n    code_1::Integer,\n    code_2::Integer\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.has_vertex-Tuple{TravelTimeGraph, Integer}","page":"Home","title":"Graphs.has_vertex","text":"has_vertex(\n    travel_time_graph::TravelTimeGraph,\n    code::Integer\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.ne-Tuple{TravelTimeGraph}","page":"Home","title":"Graphs.ne","text":"ne(travel_time_graph::TravelTimeGraph) -> Any\n\n\nGet the number of edges in the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.nv-Tuple{TravelTimeGraph}","page":"Home","title":"Graphs.nv","text":"nv(travel_time_graph::TravelTimeGraph) -> Any\n\n\nGet the number of vertices in the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.weights-Tuple{TravelTimeGraph}","page":"Home","title":"Graphs.weights","text":"weights(\n    travel_time_graph::TravelTimeGraph\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nGet the weights (cost matrix) of the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization._add_network_arc!-Tuple{TimeSpaceGraph, NetworkNode, NetworkNode, NetworkArc}","page":"Home","title":"TransportationPlanningOptimization._add_network_arc!","text":"_add_network_arc!(\n    time_space_graph::TimeSpaceGraph,\n    origin::NetworkNode,\n    destination::NetworkNode,\n    arc::NetworkArc\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization._add_network_arc_to_travel_time_graph!-Tuple{MetaGraphsNext.MetaGraph, NetworkNode, NetworkNode, NetworkArc, Int64, Bool}","page":"Home","title":"TransportationPlanningOptimization._add_network_arc_to_travel_time_graph!","text":"_add_network_arc_to_travel_time_graph!(\n    g::MetaGraphsNext.MetaGraph,\n    origin::NetworkNode,\n    destination::NetworkNode,\n    arc::NetworkArc,\n    max_time_steps::Int64,\n    is_date_arrival::Bool\n)\n\n\nAdd arcs corresponding to a network arc to the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization._add_network_node!-Tuple{TimeSpaceGraph, NetworkNode}","page":"Home","title":"TransportationPlanningOptimization._add_network_node!","text":"_add_network_node!(\n    time_space_graph::TimeSpaceGraph,\n    node::NetworkNode\n)\n\n\nAdds a timed copy of the given network node for each time step in the time horizon.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization._add_network_node_to_travel_time_graph!-Union{Tuple{B}, Tuple{MetaGraphsNext.MetaGraph, NetworkNode, Dict{String, Vector{B}}, Int64, Bool}} where B<:Bundle","page":"Home","title":"TransportationPlanningOptimization._add_network_node_to_travel_time_graph!","text":"_add_network_node_to_travel_time_graph!(\n    g::MetaGraphsNext.MetaGraph,\n    node::NetworkNode,\n    node_to_bundles_map::Dict{String, Array{B<:Bundle, 1}},\n    max_time_steps::Int64,\n    is_date_arrival::Bool\n)\n\n\nAdd timed copies of a network node to the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization._compute_bundle_arcs-Tuple{MetaGraphsNext.MetaGraph, Vector{Int64}, Vector{Int64}}","page":"Home","title":"TransportationPlanningOptimization._compute_bundle_arcs","text":"_compute_bundle_arcs(\n    graph::MetaGraphsNext.MetaGraph,\n    origin_codes::Vector{Int64},\n    destination_codes::Vector{Int64}\n) -> Vector{Vector{Tuple{Int64, Int64}}}\n\n\nCompute usable arcs for each bundle by finding all arcs that lie on paths from the bundle's origin to its destination in the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization._is_shortcut_arc-Tuple{NetworkArc}","page":"Home","title":"TransportationPlanningOptimization._is_shortcut_arc","text":"_is_shortcut_arc(arc::NetworkArc) -> Bool\n\n\nIncrementally add a path (sequence of TTG node codes) for a bundle and update the solution. This updates bundle_paths, commodities_on_arcs, bin_assignments, and arc_costs.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.build_instance-Union{Tuple{I}, Tuple{ID}, Tuple{is_date_arrival}, Tuple{Vector{<:NetworkNode}, Vector{<:Arc}, Array{Commodity{is_date_arrival, ID, I}, 1}, Dates.Period, Tuple}} where {is_date_arrival, ID, I}","page":"Home","title":"TransportationPlanningOptimization.build_instance","text":"build_instance(\n    nodes::Vector{<:NetworkNode},\n    raw_arcs::Vector{<:Arc},\n    commodities::Array{Commodity{is_date_arrival, ID, I}, 1},\n    time_step::Dates.Period,\n    arc_cost_types::Tuple;\n    group_by,\n    wrap_time,\n    check_bundle_feasibility\n) -> Instance{B, G, TimeSpaceGraph{MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Tuple{String, Int64}, NetworkNode, NetworkArc, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64}}, TTG} where {B<:(Bundle{Order{_A, _B}} where {_B, _A}), G<:(NetworkGraph{G} where G<:(MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64} where {_A, _B, _C})), TTG<:(TravelTimeGraph{_A, MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Tuple{String, Int64}, NetworkNode, NetworkArc, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64}} where _A)}\n\n\nBuild an Instance from raw_arcs::Vector{<:Arc} with explicit arc_cost_types for type stability.\n\nThis variant converts raw_arcs into NetworkArcs using collect_arcs(arc_cost_types, raw_arcs, time_step) and then delegates to build_instance(nodes, arcs, commodities, time_step; group_by, wrap_time).\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.build_instance-Union{Tuple{I}, Tuple{ID}, Tuple{is_date_arrival}, Tuple{Vector{<:NetworkNode}, Vector{<:Tuple{String, String, var\"#s66\"} where var\"#s66\"<:NetworkArc}, Array{Commodity{is_date_arrival, ID, I}, 1}, Dates.Period}} where {is_date_arrival, ID, I}","page":"Home","title":"TransportationPlanningOptimization.build_instance","text":"build_instance(\n    nodes::Vector{<:NetworkNode},\n    arcs::Vector{<:Tuple{String, String, var\"#s66\"} where var\"#s66\"<:NetworkArc},\n    commodities::Array{Commodity{is_date_arrival, ID, I}, 1},\n    time_step::Dates.Period;\n    group_by,\n    wrap_time,\n    check_bundle_feasibility\n) -> Instance{B, G, TimeSpaceGraph{MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Tuple{String, Int64}, NetworkNode, NetworkArc, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64}}, TTG} where {B<:(Bundle{Order{_A, _B}} where {_B, _A}), G<:(NetworkGraph{G} where G<:(MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, _A, _B, _C, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64} where {_A, _B, _C})), TTG<:(TravelTimeGraph{_A, MetaGraphsNext.MetaGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Tuple{String, Int64}, NetworkNode, NetworkArc, Nothing, MetaGraphsNext.var\"#MetaGraph##10#MetaGraph##11\", Float64}} where _A)}\n\n\nBuild an Instance from normalized inputs.\n\nThis function expects nodes and arcs already in NetworkGraph form (i.e., arcs are tuples (origin_id, destination_id, NetworkArc)), and commodities are user-facing Commodity objects. In brief, it:\n\nDetermines the instance start date (arrival- or departure-based) and converts dates into discrete time step indices using period_steps.\nExpands each Commodity into LightCommodity items and groups them into Orders (by time step, origin, destination and group_by) and Bundles (by origin, destination and group).\nComputes time_horizon_length (accounting for max_delivery_time unless wrap_time=true), constructs TimeSpaceGraph and TravelTimeGraph, and returns a populated Instance.\n\nArguments:\n\nnodes::Vector{<:NetworkNode}\narcs::Vector{<:Tuple{String,String,<:NetworkArc}}\ncommodities::Vector{Commodity}\ntime_step::Period\n\nKeywords:\n\ngroup_by (default: _default_group_by): function grouping commodities into orders\nwrap_time (default: false): whether the time horizon wraps (cyclic)\ncheck_bundle_feasibility (default: true): whether to validate that bundles have feasible paths after applying forbidden constraints\n\nSee also: the Instance constructor which accepts Arc inputs and performs automatic cost-type inference.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.bundle_count-Tuple{Instance}","page":"Home","title":"TransportationPlanningOptimization.bundle_count","text":"bundle_count(instance::Instance) -> Int64\n\n\nReturn the number of bundles in the instance.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.collect_arcs-Tuple{Tuple, Vector{<:Arc}, Dates.Period}","page":"Home","title":"TransportationPlanningOptimization.collect_arcs","text":"collect_arcs(cost_types, arcs; validate=true)\n\nCollect an iterable of NetworkArcs into a type-stable vector with the specified cost types. This is useful for creating heterogeneous arc collections with multiple cost function types while maintaining type stability.\n\nArguments\n\ncost_types: A tuple or Union of cost function types\nTuple syntax: (LinearArcCost, BinPackingArcCost)\nUnion syntax: Union{LinearArcCost, BinPackingArcCost}\narcs: Iterable of NetworkArc objects with potentially different cost types\nvalidate: Whether to validate that all arc cost types are included (default: true)\n\nExamples\n\n# Using tuple (recommended)\narcs = [NetworkArc(cost=LinearArcCost(1.0), ...), NetworkArc(cost=BinPackingArcCost(2.0, 10), ...)]\ntyped_arcs = collect_arcs((LinearArcCost, BinPackingArcCost), arcs)\n\n# Using Union (also works)\nconst MyCostTypes = Union{LinearArcCost, BinPackingArcCost}\ntyped_arcs = collect_arcs(MyCostTypes, arcs)\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.commodity_count-Tuple{Instance}","page":"Home","title":"TransportationPlanningOptimization.commodity_count","text":"commodity_count(instance::Instance) -> Any\n\n\nReturn the number of commodities in the instance.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.compute_bin_assignments-Union{Tuple{C}, Tuple{BinPackingArcCost, Vector{C}}} where C<:LightCommodity","page":"Home","title":"TransportationPlanningOptimization.compute_bin_assignments","text":"compute_bin_assignments(\n    arc_f::BinPackingArcCost,\n    commodities::Array{C<:LightCommodity, 1}\n) -> Vector\n\n\nCompute the bin assignments for a list of commodities using the First-Fit Decreasing (FFD) heuristic. Returns a vector of Bin objects.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.compute_node_to_bundles_map-Union{Tuple{Vector{B}}, Tuple{B}} where B<:Bundle","page":"Home","title":"TransportationPlanningOptimization.compute_node_to_bundles_map","text":"compute_node_to_bundles_map(\n    bundles::Array{B<:Bundle, 1}\n) -> Dict{String, Vector{B}} where B<:Bundle\n\n\nCompute a mapping from node IDs to the list of bundles that originate from that node.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.compute_ttg_edge_incremental_cost-Union{Tuple{C}, Tuple{Solution{C}, Instance, Bundle, Any, Any}} where C","page":"Home","title":"TransportationPlanningOptimization.compute_ttg_edge_incremental_cost","text":"compute_ttg_edge_incremental_cost(sol, instance, bundle, u_ttg_label, v_ttg_label)\n\nCompute the incremental cost of a TravelTimeGraph edge for a specific bundle, considering all its orders and their projections to the TimeSpaceGraph.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.cost-Tuple{Solution, Instance}","page":"Home","title":"TransportationPlanningOptimization.cost","text":"cost(sol::Solution, instance::Instance) -> Float64\n\n\nCompute the cost of the solution (legacy signature for compatibility).\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.cost-Tuple{Solution}","page":"Home","title":"TransportationPlanningOptimization.cost","text":"cost(sol)\n\nCompute the cost of the solution by summing individual arc costs.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.evaluate-Tuple{AbstractArcCostFunction, Vector{<:LightCommodity}}","page":"Home","title":"TransportationPlanningOptimization.evaluate","text":"evaluate(\n    arc_f::AbstractArcCostFunction,\n    commodities::Vector{<:LightCommodity}\n) -> Float64\n\n\nFallback evaluate for unknown cost function types.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.evaluate-Tuple{BinPackingArcCost, Vector{<:LightCommodity}}","page":"Home","title":"TransportationPlanningOptimization.evaluate","text":"evaluate(\n    arc_f::BinPackingArcCost,\n    commodities::Vector{<:LightCommodity}\n) -> Float64\n\n\nEvaluate the cost of transporting a list of commodities on an arc with a bin-packing cost function. The cost is based on the number of bins (trucks) needed to transport all commodities. Uses the First-Fit Decreasing (FFD) heuristic to determine bin assignments and count.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.evaluate-Tuple{LinearArcCost, Vector{<:LightCommodity}}","page":"Home","title":"TransportationPlanningOptimization.evaluate","text":"evaluate(\n    arc_f::LinearArcCost,\n    commodities::Vector{<:LightCommodity}\n) -> Float64\n\n\nEvaluate the cost of transporting a list of commodities on an arc with a linear cost function. The cost is proportional to the total size of all commodities.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.greedy_heuristic-Tuple{Instance}","page":"Home","title":"TransportationPlanningOptimization.greedy_heuristic","text":"greedy_heuristic(\n    instance::Instance\n) -> Solution{LightCommodity{_A, _B}} where {_A, _B}\n\n\nConstruct a solution by inserting bundles one by one into an initially empty solution. Bundles are processed in the order they appear in the instance.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.incremental_cost-Union{Tuple{C}, Tuple{AbstractArcCostFunction, Vector{C}, Vector{C}}} where C<:LightCommodity","page":"Home","title":"TransportationPlanningOptimization.incremental_cost","text":"incremental_cost(arc_f::AbstractArcCostFunction, existing_commodities, new_commodities)\n\nCompute the additional cost of adding new_commodities to an arc that already contains existing_commodities.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.infer_cost_types-Tuple{Vector{<:Arc}}","page":"Home","title":"TransportationPlanningOptimization.infer_cost_types","text":"infer_cost_types(arcs::Vector{<:Arc}) -> Tuple\n\n\nInfer the cost types present in a vector of arcs by scanning their actual cost function types. Returns a tuple of unique cost types found in the arcs.\n\nThis is a runtime operation that enables automatic cost type detection, but the result can be passed to type-stable inner functions via function barriers.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.insert_bundle!-Tuple{Solution, Instance, Int64}","page":"Home","title":"TransportationPlanningOptimization.insert_bundle!","text":"insert_bundle!(sol, instance, bundle_idx)\n\nFind the cheapest path for a bundle in the TravelTimeGraph (considering incremental costs) and add it to the solution.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.is_feasible-Tuple{Solution, Instance}","page":"Home","title":"TransportationPlanningOptimization.is_feasible","text":"is_feasible(\n    sol::Solution,\n    instance::Instance;\n    verbose\n) -> Bool\n\n\nCheck if a solution is feasible for a given instance. Feasibility requires:\n\nEvery bundle in the instance must have a corresponding path in the solution.\nEvery path must exist (each arc exists in the graph).\nEvery path must start at the bundle's designated entry node (origin_codes).\nEvery path must end at the bundle's designated exit node (destination_codes).\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.order_count-Tuple{Instance}","page":"Home","title":"TransportationPlanningOptimization.order_count","text":"order_count(instance::Instance) -> Int64\n\n\nReturn the number of orders in the instance.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.period_steps-Tuple{Dates.Period, Dates.Period}","page":"Home","title":"TransportationPlanningOptimization.period_steps","text":"period_steps(p::Period, step::Period; roundup=floor)::Int\n\nCompute how many complete step units fit into period p.\n\nArguments\n\np::Period: the period to measure\nstep::Period: the step size\nroundup::Function: ceil (default) or floor\n\nReturns\n\nAn integer representing the number of steps.\n\nExamples\n\nperiod_steps(Day(10), Week(1))                    # => 2 (default ceil)\nperiod_steps(Day(10), Week(1); roundup=floor)     # => 1\nperiod_steps(Hour(25), Week(1))                   # => 1\nperiod_steps(Day(1), Hour(12); roundup=floor)     # => 2\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.project_bundle_path_to_order_paths-Tuple{Solution, Instance}","page":"Home","title":"TransportationPlanningOptimization.project_bundle_path_to_order_paths","text":"project_bundle_path_to_order_paths(\n    sol::Solution,\n    instance::Instance\n) -> Dict{Order, Vector{Int64}}\n\n\nProject bundle paths to order paths on the Time Space Graph. Returns a Dict mapping Order to a Vector of TSG node codes (Int).\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.project_to_time_space_graph-Union{Tuple{is_date_arrival}, Tuple{Int64, Order{is_date_arrival}, Instance}} where is_date_arrival","page":"Home","title":"TransportationPlanningOptimization.project_to_time_space_graph","text":"project_to_time_space_graph(\n    ttg_node_code::Int64,\n    order::Order{is_date_arrival},\n    instance::Instance\n) -> Integer\n\n\nProject a node code from the TravelTimeGraph to a node code in the TimeSpaceGraph for a specific order. The projection converts the graph-specific time τ (budget or elapsed) into absolute time t in the TimeSpaceGraph.\n\nTime Projection Formulas\n\nIf is_date_arrival = true: t = deadline - τ\nIf is_date_arrival = false: t = release + τ\n\nThrows a DomainError if the resulting t is outside the instance time horizon [1, time_horizon_length].\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.read_solution_csv-Tuple{String, Instance}","page":"Home","title":"TransportationPlanningOptimization.read_solution_csv","text":"read_solution_csv(filename::String, instance::Instance)\n\nRead a solution from a CSV file and reconstruct the Solution object. Assumes the CSV follows the format: route_id,origin_id,destination_id,node_id,point_number,point_type.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.time_horizon-Tuple{Instance}","page":"Home","title":"TransportationPlanningOptimization.time_horizon","text":"time_horizon(instance::Instance) -> UnitRange{Int64}\n\n\nReturn the time horizon of the instance as a range of discrete time steps.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.time_horizon-Tuple{TimeSpaceGraph}","page":"Home","title":"TransportationPlanningOptimization.time_horizon","text":"time_horizon(g::TimeSpaceGraph) -> UnitRange{Int64}\n\n\nReturns the range of time steps in the time space graph.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.time_horizon-Tuple{TravelTimeGraph}","page":"Home","title":"TransportationPlanningOptimization.time_horizon","text":"time_horizon(\n    travel_time_graph::TravelTimeGraph\n) -> UnitRange{Int64}\n\n\nGet the time horizon of the travel-time graph.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.total_size-Tuple{Bundle}","page":"Home","title":"TransportationPlanningOptimization.total_size","text":"total_size(bundle::Bundle) -> Float64\n\n\nCompute the total size of all commodities in the bundle.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.total_size-Tuple{Order}","page":"Home","title":"TransportationPlanningOptimization.total_size","text":"total_size(order::Order) -> Float64\n\n\nCompute the total size of all commodities in the order.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.travel_time_steps-Tuple{NetworkArc}","page":"Home","title":"TransportationPlanningOptimization.travel_time_steps","text":"travel_time_steps(arc::NetworkArc) -> Int64\n\n\nReturn the travel duration (in discrete steps) associated with the arc.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.validate_bundle_feasibility-Tuple{TravelTimeGraph, Int64, Bundle}","page":"Home","title":"TransportationPlanningOptimization.validate_bundle_feasibility","text":"validate_bundle_feasibility(\n    ttg::TravelTimeGraph,\n    bundle_idx::Int64,\n    bundle::Bundle\n) -> Bool\n\n\nValidate that a bundle can reach its destination from its origin while respecting forbidden constraints.\n\nUses BFS to check reachability in the TravelTimeGraph, avoiding forbidden nodes and arcs. Explores all edges in the time-expanded graph to check if ANY feasible path exists. Returns true if the bundle is feasible, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#TransportationPlanningOptimization.write_solution_csv-Tuple{String, Solution, Instance}","page":"Home","title":"TransportationPlanningOptimization.write_solution_csv","text":"write_solution_csv(filename::String, sol::Solution, instance::Instance)\n\nWrite the solution to a CSV file in the following format: route_id,origin_id,destination_id,node_id,point_number,point_type\n\nThe paths are written in reverse order (from destination to origin) to match the user's requested format.\n\n\n\n\n\n","category":"method"}]
}
