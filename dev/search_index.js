var documenterSearchIndex = {"docs":
[{"location":"#NetworkDesignOptimization","page":"Home","title":"NetworkDesignOptimization","text":"Documentation for NetworkDesignOptimization.\n\n","category":"section"},{"location":"#NetworkDesignOptimization.Commodity","page":"Home","title":"NetworkDesignOptimization.Commodity","text":"struct Commodity{is_date_arrival, ID, I}\n\nUser-facing commodity data structure for parsing input data.\n\nThis structure is designed to be easy to instantiate from CSV, JSON, or other data sources. Once all commodities are loaded, they are consolidated into optimized internal structures (Commodity, Order, Bundle) based on problem-specific consolidation rules.\n\nType Parameters\n\nis_date_arrival::Bool: true if date represents arrival, false if departure\nID: Type for node identifiers (e.g., String, Int)\nI: Type for additional problem-specific information\n\nFields\n\norigin_id::Any: origin node identifier\ndestination_id::Any: destination node identifier\ndate::Dates.DateTime: date information associated with the commodity\nsize::Float64: size of the commodity\ninfo::Any: additional problem-specific information\n\nExamples\n\n# Inbound logistics (arrival date)\nCommodity(\n    origin_id = \"SUPPLIER_A\",\n    destination_id = \"PLANT_PARIS\",\n    arrival_date = Date(2025, 11, 20),\n    size = 150.0,\n    info = (part_id = \"ENGINE_V6\", priority = :high)\n)\n\n# Outbound logistics (departure date)\nCommodity(\n    origin_id = \"PLANT_PARIS\",\n    destination_id = \"DEALER_LYON\",\n    departure_date = Date(2025, 11, 18),\n    size = 1.0,  # 1 vehicle\n    info = (model = \"Clio\", color = \"Blue\")\n)\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.TypedInstance","page":"Home","title":"NetworkDesignOptimization.TypedInstance","text":"TypedInstance{CostUnion, InfoUnion}\n\nA type-stable container for network design instances with heterogeneous arc cost functions. This struct automatically handles type stability when you have multiple cost function types.\n\nType Parameters\n\nCostUnion: A Union type of all cost functions used (e.g., Union{LinearArcCost, BinPackingArcCost})\nInfoUnion: A Union type of all info types used\n\nExample\n\n# Define your cost types\nconst MyCostTypes = Union{LinearArcCost, BinPackingArcCost}\n\n# Create instance (arcs will be automatically converted)\ninstance = TypedInstance{MyCostTypes}(nodes, arcs)\n\n# Access type-stable arcs\nfor arc in instance.arcs\n    cost = evaluate(arc.cost)  # Fully type-stable!\nend\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.collect_arcs-Tuple{Tuple, Any}","page":"Home","title":"NetworkDesignOptimization.collect_arcs","text":"collect_arcs(cost_types, arcs; validate=true)\n\nCollect an iterable of NetworkArcs into a type-stable vector with the specified cost types. This is useful for creating heterogeneous arc collections with multiple cost function types while maintaining type stability.\n\nArguments\n\ncost_types: A tuple or Union of cost function types\nTuple syntax: (LinearArcCost, BinPackingArcCost)\nUnion syntax: Union{LinearArcCost, BinPackingArcCost}\narcs: Iterable of NetworkArc objects with potentially different cost types\nvalidate: Whether to validate that all arc cost types are included (default: true)\n\nExamples\n\n# Using tuple (recommended)\narcs = [NetworkArc(cost=LinearArcCost(1.0), ...), NetworkArc(cost=BinPackingArcCost(2.0, 10), ...)]\ntyped_arcs = collect_arcs((LinearArcCost, BinPackingArcCost), arcs)\n\n# Using Union (also works)\nconst MyCostTypes = Union{LinearArcCost, BinPackingArcCost}\ntyped_arcs = collect_arcs(MyCostTypes, arcs)\n\n\n\n\n\n","category":"method"}]
}
