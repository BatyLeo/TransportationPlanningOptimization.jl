var documenterSearchIndex = {"docs":
[{"location":"#NetworkDesignOptimization","page":"Home","title":"NetworkDesignOptimization","text":"Documentation for NetworkDesignOptimization.\n\n","category":"section"},{"location":"#NetworkDesignOptimization.Arc","page":"Home","title":"NetworkDesignOptimization.Arc","text":"struct Arc{C<:AbstractArcCostFunction, K, T<:Dates.Period}\n\nRepresentation of an arc in the network graph.\n\nFields\n\norigin_id::String: id of the origin node\ndestination_id::String: id of the destination node\ntravel_time::Dates.Period: travel time in number of discrete time steps (0 if less than the time discretization step)\ncapacity::Int64: capacity of the arc (in size units)\ncost::AbstractArcCostFunction: cost function associated with the arc\ninfo::Any: additional information associated with the arc\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.Commodity","page":"Home","title":"NetworkDesignOptimization.Commodity","text":"struct Commodity{is_date_arrival, ID, I}\n\nUser-facing commodity data structure for parsing input data.\n\nThis structure is designed to be easy to instantiate from CSV, JSON, or other data sources. Once all commodities are loaded, they are consolidated into optimized internal structures (Commodity, Order, Bundle) based on problem-specific consolidation rules.\n\nType Parameters\n\nis_date_arrival::Bool: true if date represents arrival, false if departure\nID: Type for node identifiers (e.g., String, Int)\nI: Type for additional problem-specific information\n\nFields\n\norigin_id::Any: origin node identifier\ndestination_id::Any: destination node identifier\ndate::Dates.DateTime: date information associated with the commodity\nmax_delivery_time::Dates.Period\nsize::Float64: size of the commodity (we assume 1D approximation)\nquantity::Int64: quantity of the commodity\ninfo::Any: additional problem-specific information\n\nExamples\n\n# Inbound logistics (arrival date)\nCommodity(\n    origin_id = \"SUPPLIER_A\",\n    destination_id = \"PLANT_PARIS\",\n    arrival_date = Date(2025, 11, 20),\n    size = 150.0,\n    info = (part_id = \"ENGINE_V6\", priority = :high)\n)\n\n# Outbound logistics (departure date)\nCommodity(\n    origin_id = \"PLANT_PARIS\",\n    destination_id = \"DEALER_LYON\",\n    departure_date = Date(2025, 11, 18),\n    size = 1.0,  # 1 vehicle\n    info = (model = \"Clio\", color = \"Blue\")\n)\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.Instance","page":"Home","title":"NetworkDesignOptimization.Instance","text":"struct Instance{B<:Bundle, G<:NetworkGraph, TSG<:TimeSpaceGraph, TTG<:TravelTimeGraph}\n\nAn Instance represents a transportation planning problem instance, containing bundles of orders, a network graph, and a time horizon.\n\nFields\n\nbundles::Vector{B} where B<:Bundle: list of bundles in the instance\nnetwork_graph::NetworkGraph: underlying network graph\ntime_horizon_length::Int64: length of the time horizon in discrete time steps\ntime_step::Dates.Period: discretization time step for the instance\ntime_space_graph::TimeSpaceGraph: time expanded graph (for order paths)\ntravel_time_graph::TravelTimeGraph: travel time graph (for bundle paths)\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.NetworkArc","page":"Home","title":"NetworkDesignOptimization.NetworkArc","text":"struct NetworkArc{C<:AbstractArcCostFunction, K}\n\nRepresentation of an arc in the network graph.\n\nFields\n\ntravel_time_steps::Int64: travel time in number of discrete time steps (0 if less than the time discretization step)\ncapacity::Int64: capacity of the arc (in size units)\ncost::AbstractArcCostFunction: cost function associated with the arc\ninfo::Any: additional information associated with the arc\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.TimeSpaceGraph","page":"Home","title":"NetworkDesignOptimization.TimeSpaceGraph","text":"struct TimeSpaceGraph{G}\n\nA TimeSpaceGraph represents a time-expanded version of a network graph, where each node is replicated for each time step in the time horizon.\n\nFields\n\ngraph::Any: underlying time-expanded graph\ntime_horizon_length::Int64: length of the time horizon in discrete time steps\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.TravelTimeGraph","page":"Home","title":"NetworkDesignOptimization.TravelTimeGraph","text":"struct TravelTimeGraph{G<:MetaGraphsNext.MetaGraph}\n\nFields\n\ngraph::MetaGraphsNext.MetaGraph: underlying time-expanded graph\nmax_time_steps::Int64: Maximum duration of a delivery\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDesignOptimization.add_network_arc!-Tuple{TimeSpaceGraph, NetworkNode, NetworkNode, NetworkArc}","page":"Home","title":"NetworkDesignOptimization.add_network_arc!","text":"add_network_arc!(\n    time_space_graph::TimeSpaceGraph,\n    origin::NetworkNode,\n    destination::NetworkNode,\n    arc::NetworkArc\n)\n\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.add_network_arc!-Tuple{TravelTimeGraph, NetworkNode, NetworkNode, NetworkArc}","page":"Home","title":"NetworkDesignOptimization.add_network_arc!","text":"add_network_arc!(\n    travel_time_graph::TravelTimeGraph,\n    origin::NetworkNode,\n    destination::NetworkNode,\n    arc::NetworkArc\n)\n\n\nAdd a network arc to the travel-time graph, creating timed copies as needed.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.add_network_node!-Tuple{TimeSpaceGraph, NetworkNode}","page":"Home","title":"NetworkDesignOptimization.add_network_node!","text":"add_network_node!(\n    time_space_graph::TimeSpaceGraph,\n    node::NetworkNode\n)\n\n\nAdds a timed copy of the given network node for each time step in the time horizon.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.add_network_node!-Union{Tuple{B}, Tuple{TravelTimeGraph, NetworkNode, Dict{String, Vector{B}}}} where B<:Bundle","page":"Home","title":"NetworkDesignOptimization.add_network_node!","text":"add_network_node!(\n    travel_time_graph::TravelTimeGraph,\n    node::NetworkNode,\n    node_to_bundles_map::Dict{String, Array{B<:Bundle, 1}}\n)\n\n\nAdd a network node to the travel-time graph, creating timed copies as needed.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.collect_arcs-Tuple{Tuple, Vector{<:Arc}, Dates.Period}","page":"Home","title":"NetworkDesignOptimization.collect_arcs","text":"collect_arcs(cost_types, arcs; validate=true)\n\nCollect an iterable of NetworkArcs into a type-stable vector with the specified cost types. This is useful for creating heterogeneous arc collections with multiple cost function types while maintaining type stability.\n\nArguments\n\ncost_types: A tuple or Union of cost function types\nTuple syntax: (LinearArcCost, BinPackingArcCost)\nUnion syntax: Union{LinearArcCost, BinPackingArcCost}\narcs: Iterable of NetworkArc objects with potentially different cost types\nvalidate: Whether to validate that all arc cost types are included (default: true)\n\nExamples\n\n# Using tuple (recommended)\narcs = [NetworkArc(cost=LinearArcCost(1.0), ...), NetworkArc(cost=BinPackingArcCost(2.0, 10), ...)]\ntyped_arcs = collect_arcs((LinearArcCost, BinPackingArcCost), arcs)\n\n# Using Union (also works)\nconst MyCostTypes = Union{LinearArcCost, BinPackingArcCost}\ntyped_arcs = collect_arcs(MyCostTypes, arcs)\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.compute_node_to_bundles_map-Union{Tuple{Vector{B}}, Tuple{B}} where B<:Bundle","page":"Home","title":"NetworkDesignOptimization.compute_node_to_bundles_map","text":"compute_node_to_bundles_map(\n    bundles::Array{B<:Bundle, 1}\n) -> Dict{String, Vector{B}} where B<:Bundle\n\n\nCompute a mapping from node IDs to the list of bundles that originate from that node.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.period_steps-Tuple{Dates.Period, Dates.Period}","page":"Home","title":"NetworkDesignOptimization.period_steps","text":"period_steps(p::Period, step::Period; roundup=floor)::Int\n\nCompute how many complete step units fit into period p.\n\nArguments\n\np::Period: the period to measure\nstep::Period: the step size\nroundup::Function: ceil (default) or floor\n\nReturns\n\nAn integer representing the number of steps.\n\nExamples\n\nperiod_steps(Day(10), Week(1))                    # => 2 (default ceil)\nperiod_steps(Day(10), Week(1); roundup=floor)     # => 1\nperiod_steps(Hour(25), Week(1))                   # => 1\nperiod_steps(Day(1), Hour(12); roundup=floor)     # => 2\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.time_horizon-Tuple{TimeSpaceGraph}","page":"Home","title":"NetworkDesignOptimization.time_horizon","text":"time_horizon(g::TimeSpaceGraph) -> UnitRange{Int64}\n\n\nReturns the range of time steps in the time space graph.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDesignOptimization.time_horizon-Tuple{TravelTimeGraph}","page":"Home","title":"NetworkDesignOptimization.time_horizon","text":"time_horizon(\n    travel_time_graph::TravelTimeGraph\n) -> UnitRange{Int64}\n\n\nGet the time horizon of the travel-time graph.\n\n\n\n\n\n","category":"method"}]
}
